{"version":3,"file":"index.js","sources":["../src/useMounted.ts","../src/useLocalStorage.ts","../src/useInjectScript.ts","../src/useNetworkStatus.ts","../src/useWindowSize.ts","../src/useToggle.ts","../src/useClosure.ts","../src/useIntersectionObserver.ts","../src/useGoogleDrivePicker.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/useFetch.ts","../src/useClipboard.ts","../src/useValue.ts","../src/useInterval.ts","../src/useTimeout.ts","../src/useAudio.ts","../src/useLazyFetch.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useMounted = () => {\n  const [mounted, setMounted] = useState<boolean>(false);\n\n  useEffect(() => {\n    setMounted(true);\n\n    return () => setMounted(false);\n  }, []);\n\n  return mounted;\n};\n\nexport default useMounted;\n","import { useState } from 'react';\n\ntype Props<T> = {\n  key: string;\n  defaultValue: T;\n};\n\nconst useLocalStorage = <T extends string>({ key, defaultValue }: Props<T>) => {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = localStorage.getItem(key);\n\n      return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n      console.log(error);\n      return defaultValue;\n    }\n  });\n\n  const setValue = (value: T | ((val: T) => T)) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n\n      setStoredValue(valueToStore);\n\n      localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  const removeValue = () => {\n    localStorage.removeItem(key);\n  };\n\n  return [storedValue, setValue, removeValue] as const;\n};\n\nexport default useLocalStorage;\n","import { useEffect, useState } from 'react';\n\ntype Props = {\n  url: string;\n  onLoad?: () => void;\n};\n\nconst useInjectScript = (props: Props) => {\n  const { url, onLoad } = props;\n\n  const [loaded, setLoaded] = useState<boolean>(false);\n  const [error, setError] = useState<boolean>(false);\n\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = url;\n    script.async = true;\n\n    script.onload = () => {\n      onLoad?.();\n\n      setLoaded(true);\n    };\n\n    script.onerror = () => {\n      setError(true);\n    };\n\n    document.body.append(script);\n\n    return () => {\n      document.body.removeChild(script);\n    };\n  }, [url, onLoad]);\n\n  return { loaded, error };\n};\n\nexport default useInjectScript;\n","import { useEffect, useState } from 'react';\n\nconst useNetworkStatus = () => {\n  const [online, setOnline] = useState<boolean>(false);\n\n  useEffect(() => {\n    const handleUpdateToOnline = () => setOnline(true);\n    const handleUpdateToOffline = () => setOnline(true);\n\n    window.addEventListener('online', handleUpdateToOnline);\n    window.addEventListener('offline', handleUpdateToOffline);\n\n    return () => {\n      window.removeEventListener('online', handleUpdateToOnline);\n      window.removeEventListener('offline', handleUpdateToOffline);\n    };\n  }, []);\n\n  return online;\n};\n\nexport default useNetworkStatus;\n","import { useEffect, useState } from 'react';\n\ntype WindowSize = {\n  width: number;\n  height: number;\n};\n\nconst useWindowSize = () => {\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n};\n\nexport default useWindowSize;\n","import { useState, useCallback } from 'react';\n\nconst useToggle = (initialValue?: boolean) => {\n  const [on, setOn] = useState<boolean>(!!initialValue);\n\n  const toggle = useCallback(() => {\n    setOn((prev) => !prev);\n  }, []);\n\n  const reset = useCallback(() => {\n    if (initialValue !== undefined) {\n      setOn(initialValue);\n    }\n  }, [initialValue]);\n\n  return [on, toggle, reset] as const;\n};\n\nexport default useToggle;\n","import { useState, useCallback } from 'react';\n\nconst useClosure = () => {\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n\n  const onOpen = useCallback(() => {\n    setIsOpen(true);\n  }, []);\n\n  const onClose = useCallback(() => {\n    setIsOpen(false);\n  }, []);\n\n  const onToggle = useCallback(() => {\n    setIsOpen((prev) => !prev);\n  }, []);\n\n  return { isOpen, onOpen, onClose, onToggle };\n};\n\nexport default useClosure;\n","import { useState, useEffect } from 'react';\n\ntype UseIntersectionObserverProps = {\n  element: Element;\n  observerConfig?: IntersectionObserverInit;\n};\n\nconst useIntersectionObserver = (props: UseIntersectionObserverProps) => {\n  const { element, observerConfig } = props;\n\n  const [isIntersecting, setIsIntersecting] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const observer = new IntersectionObserver((entries) => {\n      setIsIntersecting(entries[0].isIntersecting);\n    }, observerConfig);\n\n    observer.observe(element);\n\n    return () => observer.disconnect();\n  }, [element, observerConfig]);\n\n  return isIntersecting;\n};\n\nexport default useIntersectionObserver;\n","import { useState, useEffect, useRef } from 'react';\n\nimport useInjectScript from './useInjectScript';\n\nexport type GoogleDrivePickerConfig = {\n  viewId: google.picker.ViewId;\n  viewMode: google.picker.DocsViewMode;\n  setIncludeFolders?: boolean;\n  setSelectFolderEnabled?: boolean;\n  supportSharedDrives?: boolean;\n  multi?: boolean;\n  mimeTypes?: string[];\n  locale?: string;\n};\n\ntype Props = {\n  appId: string;\n  clientId: string;\n  apiKey: string;\n};\n\nexport const useGoogleDrivePicker = (\n  props: Props,\n): [\n  (config?: GoogleDrivePickerConfig) => void,\n  google.picker.ResponseObject | undefined,\n] => {\n  const { appId, clientId, apiKey } = props;\n\n  const [pickerApiLoaded, setPickerApiLoaded] = useState(false);\n  const [callbackInfo, setCallbackInfo] =\n    useState<google.picker.ResponseObject>();\n  const [pickerConfig, setPickerConfig] = useState<GoogleDrivePickerConfig>();\n\n  const oauthTokenRef = useRef<string>();\n\n  const { loaded } = useInjectScript({\n    url: 'https://apis.google.com/js/api.js',\n  });\n\n  const scope = ['https://www.googleapis.com/auth/drive'];\n\n  useEffect(() => {\n    const loadApis = () => {\n      gapi.load('auth', () => {});\n      gapi.load('picker', { callback: handlePickerApiLoaded });\n    };\n\n    if (loaded) {\n      loadApis();\n    }\n  }, [loaded]);\n\n  const handlePickerApiLoaded = () => {\n    setPickerApiLoaded(true);\n  };\n\n  const handleAuth = () => {\n    gapi.auth.authorize(\n      {\n        client_id: clientId,\n        scope,\n        immediate: false,\n      },\n      handleAuthResult,\n    );\n  };\n\n  const handleAuthResult = (authResult: {\n    access_token: string;\n    error: string;\n  }) => {\n    if (authResult && !authResult.error) {\n      oauthTokenRef.current = authResult.access_token;\n      createPicker();\n    }\n  };\n\n  const openPicker = (config?: GoogleDrivePickerConfig) => {\n    setPickerConfig(config);\n\n    if (!oauthTokenRef.current) {\n      handleAuth();\n      return;\n    }\n\n    createPicker();\n  };\n\n  const createPicker = () => {\n    if (!pickerApiLoaded || !oauthTokenRef.current) {\n      return;\n    }\n\n    const {\n      viewId = google.picker.ViewId.DOCS,\n      viewMode = google.picker.DocsViewMode.GRID,\n      multi,\n      supportSharedDrives,\n      mimeTypes,\n      locale = 'en-US',\n      setIncludeFolders,\n      setSelectFolderEnabled,\n    } = pickerConfig || {};\n\n    const view = new google.picker.DocsView(viewId);\n    view.setMode(viewMode);\n\n    if (setIncludeFolders) {\n      view.setIncludeFolders(true);\n    }\n\n    if (setSelectFolderEnabled) {\n      view.setSelectFolderEnabled(true);\n    }\n\n    if (mimeTypes && mimeTypes.length > 0) {\n      view.setMimeTypes(mimeTypes.join(','));\n    }\n\n    const picker = new google.picker.PickerBuilder()\n      .setAppId(appId)\n      .setOAuthToken(oauthTokenRef.current)\n      .setDeveloperKey(apiKey)\n      .setLocale(locale)\n      .setCallback(handlePickerCallback)\n      .addView(view);\n\n    if (multi) {\n      picker.enableFeature(google.picker.Feature.MULTISELECT_ENABLED);\n    }\n\n    if (supportSharedDrives) {\n      picker.enableFeature(google.picker.Feature.SUPPORT_DRIVES);\n    }\n\n    picker.build().setVisible(true);\n  };\n\n  const handlePickerCallback = (result: google.picker.ResponseObject) => {\n    if (result.action === google.picker.Action.PICKED) {\n      setCallbackInfo(result);\n    }\n  };\n\n  return [openPicker, callbackInfo];\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useState, useEffect, useCallback } from 'react';\n\nexport type FetchConfig = {\n  url: string;\n  requestConfig?: RequestInit;\n};\n\nexport const useFetch = <T>(config: FetchConfig) => {\n  const { url, requestConfig } = config;\n\n  const [data, setData] = useState<T>();\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<boolean>(false);\n\n  useEffect(() => {\n    handleLoadData();\n  }, []);\n\n  const handleLoadData = useCallback(async () => {\n    setLoading(true);\n\n    try {\n      const res = await fetch(url, requestConfig);\n      const parsedData = await res.json();\n\n      setData(parsedData);\n    } catch (error) {\n      setError(true);\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n\n  return { data, loading, error, refetch: handleLoadData };\n};\n","import { useState, useCallback } from 'react';\n\nexport type UseClipboardProps = {\n  text: string;\n  successDurationInSeconds?: number;\n};\n\nexport const useClipboard = (props: UseClipboardProps) => {\n  const { text, successDurationInSeconds } = props;\n\n  const [isCopied, setIsCopied] = useState<boolean>(false);\n\n  const onCopy = useCallback(() => {\n    navigator.clipboard.writeText(text);\n\n    setIsCopied(true);\n\n    if (successDurationInSeconds) {\n      setTimeout(() => setIsCopied(false), successDurationInSeconds * 1000);\n    }\n  }, [text, successDurationInSeconds]);\n\n  return { isCopied, onCopy };\n};\n","import { useRef, useEffect } from 'react';\n\nexport type useValueProps<T> = {\n  value: T;\n  onChange: (newValue: T) => void;\n};\n\nexport const useValue = <T>(props: useValueProps<T>) => {\n  const { value, onChange } = props;\n\n  const valueRef = useRef<T>(value);\n\n  useEffect(() => {\n    if (valueRef.current !== value) {\n      valueRef.current = value;\n\n      onChange(value);\n    }\n  }, [value]);\n\n  return valueRef.current;\n};\n","import { useEffect } from 'react';\n\nexport type UseIntervalProps = {\n  intervalInSeconds: number | null;\n  callback: () => void;\n};\n\nexport const useInterval = (props: UseIntervalProps) => {\n  const { intervalInSeconds, callback } = props;\n\n  useEffect(() => {\n    const intervalId = setInterval(\n      callback,\n      intervalInSeconds ? intervalInSeconds * 1000 : undefined,\n    );\n\n    return () => clearInterval(intervalId);\n  }, [intervalInSeconds]);\n};\n","import { useEffect } from 'react';\n\nexport type UseTimeoutProps = {\n  callback: () => void;\n  delayInSeconds: number;\n};\n\nexport const useTimeout = (props: UseTimeoutProps) => {\n  const { callback, delayInSeconds } = props;\n\n  useEffect(() => {\n    const timeoutId = setTimeout(callback, delayInSeconds * 1000);\n\n    return () => clearTimeout(timeoutId);\n  }, [delayInSeconds]);\n};\n","import { useState, useEffect, useMemo, useCallback } from 'react';\n\nexport type UseAudioProps = {\n  url: string;\n  initialState?: boolean;\n};\n\nexport const useAudio = (props: UseAudioProps) => {\n  const { url, initialState } = props;\n\n  const [isPlaying, setIsPlaying] = useState<boolean>(!!initialState);\n\n  const audio = useMemo<HTMLAudioElement>(() => {\n    const audio = new Audio(url);\n\n    if (initialState) {\n      audio.play();\n    }\n\n    return audio;\n  }, [url, initialState]);\n\n  useEffect(() => {\n    const handleAudioEnded = () => setIsPlaying(false);\n\n    audio.addEventListener('ended', handleAudioEnded);\n\n    return () => {\n      audio.removeEventListener('ended', handleAudioEnded);\n    };\n  }, [audio]);\n\n  const onPlay = useCallback(() => {\n    audio.play();\n\n    setIsPlaying(true);\n  }, [audio]);\n\n  const onPause = useCallback(() => {\n    audio.pause();\n\n    setIsPlaying(false);\n  }, [audio]);\n\n  const onToggle = useCallback(() => {\n    isPlaying ? onPause() : onPlay();\n  }, [audio, isPlaying]);\n\n  return { isPlaying, onPlay, onPause, onToggle };\n};\n","import { useState, useEffect, useCallback } from 'react';\n\nexport type UseLazyFetchProps = {\n  url: string;\n  requestConfig?: RequestInit;\n};\n\nexport const useLazyFetch = <T>(props: UseLazyFetchProps) => {\n  const { url, requestConfig } = props;\n\n  const [data, setData] = useState<T>();\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<boolean>(false);\n\n  useEffect(() => {\n    handleLoadData();\n  }, []);\n\n  const handleLoadData = useCallback(async () => {\n    setLoading(true);\n\n    try {\n      const res = await fetch(url, requestConfig);\n      const parsedData = await res.json();\n\n      setData(parsedData);\n    } catch (error) {\n      setError(true);\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n\n  return [handleLoadData, { data, loading, error }] as const;\n};\n"],"names":["useMounted","useState","mounted","setMounted","useEffect","useLocalStorage","key","defaultValue","item","localStorage","getItem","JSON","parse","error","console","log","storedValue","setStoredValue","setValue","value","valueToStore","Function","setItem","stringify","removeValue","removeItem","useInjectScript","props","url","onLoad","loaded","setLoaded","setError","script","document","createElement","src","async","onload","onerror","body","append","removeChild","useNetworkStatus","online","setOnline","handleUpdateToOnline","handleUpdateToOffline","window","addEventListener","removeEventListener","useWindowSize","width","innerWidth","height","innerHeight","windowSize","setWindowSize","handleResize","useToggle","initialValue","on","setOn","toggle","useCallback","prev","reset","undefined","useClosure","isOpen","setIsOpen","onOpen","onClose","onToggle","useIntersectionObserver","element","observerConfig","isIntersecting","setIsIntersecting","observer","IntersectionObserver","entries","observe","disconnect","useGoogleDrivePicker","appId","clientId","apiKey","pickerApiLoaded","setPickerApiLoaded","callbackInfo","setCallbackInfo","pickerConfig","setPickerConfig","oauthTokenRef","useRef","scope","loadApis","gapi","load","callback","handlePickerApiLoaded","handleAuth","auth","authorize","client_id","immediate","handleAuthResult","authResult","current","access_token","createPicker","openPicker","config","viewId","google","picker","ViewId","DOCS","viewMode","DocsViewMode","GRID","multi","supportSharedDrives","mimeTypes","locale","setIncludeFolders","setSelectFolderEnabled","view","DocsView","setMode","length","setMimeTypes","join","PickerBuilder","setAppId","setOAuthToken","setDeveloperKey","setLocale","setCallback","handlePickerCallback","addView","enableFeature","Feature","MULTISELECT_ENABLED","SUPPORT_DRIVES","build","setVisible","result","action","Action","PICKED","useFetch","requestConfig","data","setData","loading","setLoading","handleLoadData","fetch","res","json","parsedData","refetch","useClipboard","text","successDurationInSeconds","isCopied","setIsCopied","onCopy","navigator","clipboard","writeText","setTimeout","useValue","onChange","valueRef","useInterval","intervalInSeconds","intervalId","setInterval","clearInterval","useTimeout","delayInSeconds","timeoutId","clearTimeout","useAudio","initialState","isPlaying","setIsPlaying","audio","useMemo","Audio","play","handleAudioEnded","onPlay","onPause","pause","useLazyFetch"],"mappings":"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"}